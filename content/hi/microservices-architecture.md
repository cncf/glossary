
---
title: माइक्रोसर्विसेज आर्किटेक्चर (Microservices architecture)
status: completed
tags: ["आर्किटेक्चर", "बेसिक्स", ""]
---

माइक्रोसर्विसेज आर्किटेक्चर एक ऐसी टेक्निक है जिसमें किसी एप्लिकेशन को छोटे-छोटे इंडिपेंडेंट माइक्रो [सर्विसेज](/hi/service/) में बांट दिया जाता है। हर सर्विस का अपना अलग काम होता है और ये मिलकर ऐसे काम करती हैं कि यूज़र को पूरा सिस्टम एक ही एप्लिकेशन जैसा लगे।

उदाहरण के लिए, नेटफ्लिक्स को देखें।
इसमें आप वीडियो देख सकते हैं, सर्च कर सकते हैं और प्रीव्यू चला सकते हैं। इसके पीछे अलग-अलग माइक्रोसर्विसेज काम कर रही होती हैं—जैसे ऑथेंटिकेशन, सर्च, और वीडियो प्लेबैक। ये आर्किटेक्चर डेवलपर्स को ज़्यादा फ्लेक्सिबिलिटी देता है ताकि वे नई फीचर्स जल्दी ला सकें या पुराने फीचर्स को अपडेट कर सकें। अगर एप्लिकेशन [मोनोलिथिक](/hi/monolithic-apps/) होता, तो ये उतना आसान नहीं होता।

## समस्या 

हर एप्लिकेशन में अलग-अलग काम करने वाले हिस्से होते हैं, और जरूरी नहीं कि सभी की डिमांड एक साथ बढ़े या घटे। मान लीजिए नेटफ्लिक्स ने एक बड़ा मार्केटिंग कैंपेन किया, जिससे नए साइनअप्स तेजी से बढ़ने लगे, लेकिन स्ट्रीमिंग की डिमांड दिन के शुरुआती घंटों में वैसे की वैसे बनी रही। अगर पूरा एप्लिकेशन मोनोलिथिक होता, तो इसे स्केल करने के लिए पूरी ऐप को ही अपग्रेड करना पड़ता, जो काफी रिसोर्स वेस्ट करता। इसके अलावा, मोनोलिथिक आर्किटेक्चर में एक और दिक्कत होती है कि सारा कोड एक ही जगह होने से कोड [टाइटली कपल्ड](/hi/tightly-coupled-architecture/) हो जाता है जिस से डेवलपर्स को किसी भी चीज़ को बदलने से पहले पुरे कोड बेस को समझना पड़ता है। माइक्रोसर्विसेज आर्किटेक्चर इन प्रॉब्लम्स को सॉल्व करता है।

## समाधान 

माइक्रोसर्विसेज मॉडल में हर सर्विस अलग से डिप्लॉय, अपडेट और स्केल की जा सकती है। इससे कई टीम्स एक ही टाइम पर एक बड़े एप्लिकेशन के अलग-अलग हिस्सों पर काम कर सकती हैं बिना एक-दूसरे के काम में परेशानी खड़ी किए। हालांकि, माइक्रोसर्विसेज अपनाने से ऑपरेशनल ओवरहेड बढ़ जाता है मतलब, आपको मैनेज करने के लिए ज्यादा सर्विसेज और इंफ्रास्ट्रक्चर चाहिए। इसी वजह से, कई [क्लाउड-नेटिव टेक्नोलॉजीज़](/hi/cloud-native-tech/) इसे आसानी से डिप्लॉय और मैनेज करने में मदद करती हैं।
